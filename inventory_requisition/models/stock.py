# coding: utf-8
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
import logging
import datetime

_logger = logging.getLogger(__name__)


class Picking(models.Model):
    _inherit = "stock.picking"

    employee_id = fields.Many2one('hr.employee', string="Requisitor",
                                  default=lambda self: self.env.user.employee_ids)

    account_analytic_id = fields.Many2one(
        'account.analytic.account',
        'Analytic Account', copy=False,
        states={'confirmed': [('readonly', False)]})

    analytic_tag_ids = fields.Many2many(
        'account.analytic.tag', string='Analytic Tags',
        copy=False,
        states={'confirmed': [('readonly', False)]})


class StockMove(models.Model):
    _inherit = "stock.move"

    def _prepare_account_move_line(
            self, qty, cost, credit_account_id, debit_account_id):
        """Setting analytic account to the new account move line generated by a
        stock move"""

        res = super(StockMove, self)._prepare_account_move_line(
            qty, cost, credit_account_id, debit_account_id)
        aml = {}
        for lines in res:
            aml = lines[2]
            aml_type = (
                aml.get('account_id') == debit_account_id and 'credit' or
                aml.get('account_id') == credit_account_id and 'debit' or
                'None')

            set_account = {
                'credit': lambda a: {
                    'analytic_account_id':
                    a.picking_id.account_analytic_id.id,
                    'analytic_tag_ids':
                    [(6, 0,
                      a.picking_id.analytic_tag_ids.ids)]}
                if a.picking_id and aml.get('quantity') < 0 else {},
                'debit': lambda a: {
                    'analytic_account_id':
                    a.picking_id.account_analytic_id.id,
                    'analytic_tag_ids':
                    [(6, 0,
                      a.picking_id.analytic_tag_ids.ids)]}
                if a.picking_id and aml.get('quantity') > 0 else {},
            }
            aml.update(set_account.get(aml_type, lambda a: {})(self))
        return res


class StockInventoryMaterialRequisition(models.Model):
    _name = "stock_inventory.material_requisition"
    _description = "Material requisition"

    name = fields.Char(string="Referencia",
                       compute='compute_folio',  store=True)
    date = fields.Datetime(string="Fecha", readonly=True,
                           default=datetime.datetime.now())
    employee_id = fields.Many2one('hr.employee', string="Requisitor")
    partner_id = fields.Many2one('res.partner', string="Proveedor", default = 1)

    service_name = fields.Char(string="Servicio")
    status = fields.Selection([
        ('open', 'Pendiente'),
        ('partially', 'Parcialmente Surtida'),
        ('denied', 'Denegada'),
        ('stocked', 'Surtida'),
        ('partially_returned', 'Parcialmente devuelta'),
        ('returned', 'Devuelto'),
        ('canceled', 'Cancelado'),
        ('done', 'Completado')],
        readonly=True, default='open', string='Estado')
    requisition_line_ids = fields.One2many(
        'stock_inventory.material_requisition.items', 'requisition_id', string='Materiales')
    dispatch_line_ids = fields.One2many(
        'stock_inventory.material_requisition.items', 'requisition_id', string='Salida')
    return_line_ids = fields.One2many(
        'stock_inventory.material_requisition.items', 'requisition_id', string='Entrada')
    total_weight = fields.Float(
        digits=(6, 2), string="Total de Kilos", store=True)
    total_items = fields.Float(
        digits=(6, 2), string="Total de Pzas", store=True)
    promise_return_date = fields.Datetime(string="Fecha Promesa Regreso")

    @api.multi
    @api.depends('date')
    def compute_folio(self):
        for rec in self:
            if isinstance(rec.id, int):
                rec.name = "RM-" + str(rec.id)

    @api.one
    def dispatch_items_button_action(self):
        status = 0
        total_weight = 0
        total_items = 0
        for line_id in self.requisition_line_ids:

            # calculate total items and total weight
            total_weight += line_id.total_weight
            total_items += line_id.quantity

            # if sum of already disptached and dispatched is equals to line_id quantity proceed to process the line
            if ((line_id.quantity_dispatched + line_id.quantity_dispatch) == line_id.quantity) and (line_id.status != 'stocked'):
                line_id.quantity_dispatched = line_id.quantity_dispatched + line_id.quantity_dispatch
                line_id.status = 'stocked'
                status = 1
            elif line_id.quantity < (line_id.quantity_dispatched + line_id.quantity_dispatch):
                raise ValidationError(
                    _('No podemos entregar más de la cantidad solicitada.'))
            elif (line_id.quantity_dispatched + line_id.quantity_dispatch) > 0 and (line_id.status != 'stocked'):
                line_id.quantity_dispatched = line_id.quantity_dispatched + line_id.quantity_dispatch
                status = 2
                line_id.status = 'partially'
            # reset quantity dispatch for each line
            line_id.quantity_dispatch = 0.0
            line_id.dispatch_date = datetime.datetime.now()
            # end for each

        if status == 1:
            self.status = 'stocked'
        elif status == 2:
            self.status = 'partially'

        self.total_items = total_items
        self.total_weight = total_weight
        return


class StockInventoryMaterialItems(models.Model):

    _name = 'stock_inventory.material_requisition.items'

    requisition_id = fields.Many2one(
        'stock_inventory.material_requisition', ondelete='cascade')
    quantity = fields.Float(digits=(6, 2), string="A enviar")
    product_id = fields.Many2one('product.product', string='Producto',
                                 ondelete='restrict', index=True)
    uom = fields.Char(related='product_id.uom_id.name',
                      string="Unidad de medida", readyonly=True)
    weight = fields.Float(related='product_id.weight',
                          string="Peso", readyonly=True)
    analytic_account = fields.Many2one('account.analytic.account', string='Cuenta Analitica',
                                       ondelete='restrict', index=True, help="Los registros de este documento no afectan en tu centro de costos")

    status = fields.Selection([
        ('open', 'Pendiente'),
        ('partially', 'Parcialmente Surtida'),
        ('denied', 'Denegada'),
        ('stocked', 'Surtida'),
        ('partially_returned', 'Parcialmente devuelta'),
        ('returned', 'Devuelto'),
        ('canceled', 'Cancelado')],
        default='open',
        readonly=True,
        string='Estado')

    # For dispatcher
    quantity_dispatch = fields.Float(digits=(6, 2), string="A entregar")
    quantity_dispatched = fields.Float(digits=(6, 2), string="Entregado")

    dispatch_date = fields.Datetime(string="Fecha de entrega")

    # For return
    quantity_return = fields.Float(digits=(6, 2), string="Cantidad a devolver")
    quantity_returned = fields.Float(digits=(6, 2), string="Cantidad devuelta")
    return_date = fields.Datetime(string="Fecha de devolución")

    @api.one
    @api.depends('quantity', 'weight')
    def _compute_total_weight(self):
        self.total_weight = self.quantity * self.weight

    total_weight = fields.Float(
        digits=(6, 2), string="Total Kg", compute='_compute_total_weight', store=True)

    def return_item(self):
        if self.quantity_returned + self.quantity_return > self.quantity_dispatched:
            raise ValidationError(
                _('No se puede recibir mayor cantidad que la que se ha prestado.'))
        elif self.quantity_return <= 0:
            raise ValidationError(
                _('Por favor ingresa una cantidad a regresar.'))
        else:
            self.quantity_returned += self.quantity_return

            if self.quantity_returned == self.quantity_dispatched:
                self.status = 'returned'
            else:
                self.status = 'partially_returned'

            self.quantity_return = 0.0
            self.return_date = datetime.datetime.now()
            self._compute_requisition_status()

    def _compute_requisition_status(self):
        requisition = self.requisition_id
        returned = True
        partially_returned = False

        for line_id in requisition.requisition_line_ids:
            if line_id.status == "returned":
                returned = True
            if line_id.status == 'partially_returned':
                returned = False
                partially_returned = True
            if line_id.status == "stocked":
                if returned:
                    partially_returned = True
                returned = False

        if returned and partially_returned is False:
            requisition.status = "returned"
        elif partially_returned:
            requisition.status = "partially_returned"
